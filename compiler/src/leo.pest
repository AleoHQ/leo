/// Identifiers
protected_name = { visibility | "let" | "for"| "if" | "else" | "as" | "return" }

identifier = @{ ((!protected_name ~ ASCII_ALPHA) | (protected_name ~ (ASCII_ALPHANUMERIC | "_"))) ~ (ASCII_ALPHANUMERIC | "_")* }


/// Visibility

visibility_public = { "public" }
visibility_private = { "private" }
visibility = { visibility_public | visibility_private }

/// Unary Operations

operation_pre_not = { "!" }
expression_not = { operation_pre_not ~ expression_term }

// expression_increment = { expression+ ~ "++" }
//
// expression_decrement = { expression ~ "--" }

/// Binary Operations

operation_and = { "&&" }
operation_or = { "||" }

operation_eq = { "==" }
operation_ne = { "!=" }

operation_ge = { ">=" }
operation_gt = { ">" }
operation_le = { "<=" }
operation_lt = { "<" }

operation_add = { "+" }
operation_sub = { "-" }
operation_mul = { "*" }
operation_div = { "/" }
operation_pow = { "**" }

operation_compare = _{
    operation_eq | operation_ne |
    operation_ge | operation_gt |
    operation_le | operation_lt
}

operation_binary = _{
    operation_compare | operation_and | operation_or |
    operation_add | operation_sub | operation_pow | operation_mul | operation_div
}

assign = { "=" }
operation_add_assign = { "+=" }
operation_sub_assign = { "-=" }
operation_mul_assign = { "*=" }
operation_div_assign = { "/=" }
operation_pow_assign = { "**=" }

operation_assign = {
    assign | operation_add_assign | operation_sub_assign |
    operation_mul_assign | operation_div_assign | operation_pow_assign
}

/// Types

type_u8 = {"u8"}
type_u16 = {"u16"}
type_u32 = {"u32"}
type_u64 = {"u64"}
type_u128 = {"u128"}
type_integer = {
    type_u8
    | type_u16
    | type_u32
    | type_u64
    | type_u128
}

type_field = {"field"}
type_group = {"group"}
type_bool = {"bool"}
type_self = {"Self"}
type_basic = { type_field | type_group | type_bool | type_integer }
type_circuit = { identifier }
type_array = {type_basic ~ ("[" ~ value ~ "]")+ }
_type = {type_self | type_array | type_basic | type_circuit}
type_list = _{(_type ~ ("," ~ _type)*)?}

/// Values

value_number = @{ "0" | ASCII_NONZERO_DIGIT ~ ASCII_DIGIT* }
value_implicit = { value_number }
value_integer = { value_number ~ type_integer }
value_field = { value_number ~ type_field }

group_tuple = {"(" ~ value_number ~ "," ~ value_number ~ ")"}
group_single_or_tuple = {value_number | group_tuple}
value_group = { group_single_or_tuple ~ type_group }
value_boolean = { "true" | "false" }
value = { value_field | value_group | value_boolean | value_integer | value_implicit }
expression_primitive = { value | identifier }

/// Variables + Mutability

mutable = {"mut"}
variable = { mutable? ~ identifier ~ (":" ~ _type)? }
variable_tuple = _{ variable ~ ("," ~ variable)* }

/// Access

from_expression = { expression }
to_expression = { expression }

range = { from_expression? ~ ".." ~ to_expression }
range_or_expression = { range | expression }

access_array = { "[" ~ range_or_expression ~ "]" }
access_call = { "(" ~ expression_tuple ~ ")" }
access_member = { "." ~ identifier }
access_static_member = { "::" ~ identifier }
access = { access_array | access_call | access_member | access_static_member}

expression_postfix = { identifier ~ access+ }

assignee_access = { access_array | access_member }
assignee = { identifier ~ assignee_access* }

spread = { "..." ~ expression }
spread_or_expression = { spread | expression }

/// Arrays

inline_array_inner = _{(spread_or_expression ~ ("," ~ NEWLINE* ~ spread_or_expression)*)?}
expression_array_inline = { "[" ~ NEWLINE* ~ inline_array_inner ~ NEWLINE* ~ "]"}
expression_array_initializer = { "[" ~ spread_or_expression ~ ";" ~ value ~ "]" }

/// Circuits

circuit_field_definition = { identifier ~ ":" ~ _type ~ NEWLINE* }

_static = {"static"}
circuit_function = {_static? ~ function_definition }

circuit_member = { circuit_function | circuit_field_definition }

circuit_definition = { "circuit" ~ identifier ~ "{" ~ NEWLINE* ~ circuit_member* ~ NEWLINE* ~ "}" ~ NEWLINE* }

circuit_field = { identifier ~ ":" ~ expression }
circuit_field_list = _{(circuit_field ~ ("," ~ NEWLINE* ~ circuit_field)*)? ~ ","? }
expression_circuit_inline = { identifier ~ "{" ~ NEWLINE* ~ circuit_field_list ~ NEWLINE* ~ "}" }

/// Conditionals

expression_conditional = { "if" ~ expression ~ "?" ~ expression ~ ":" ~ expression}

/// Expressions

expression_term = {
    ("(" ~ expression ~ ")")
    | expression_circuit_inline
    | expression_conditional
    | expression_postfix
    | expression_primitive
    | expression_not
//     | expression_increment
//     | expression_decrement
    | expression_array_inline
    | expression_array_initializer
}

expression = { expression_term ~ (operation_binary ~ expression_term)* }
expression_tuple = _{ (expression ~ ("," ~ expression)*)? }

/// Asserts

assert_eq = {"assert_eq!" ~ "(" ~ NEWLINE* ~ expression ~ "," ~ NEWLINE* ~ expression ~ NEWLINE* ~ ")" ~ LINE_END}
// assert_true = {"assert"}

/// Conditionals
conditional_nested_or_end = { statement_conditional | "{" ~ NEWLINE* ~ statement+ ~ "}"}

/// Statements
statement_return = { "return" ~ expression_tuple }
statement_definition = { "let" ~ variable ~ "=" ~ expression ~ LINE_END}
statement_assign = { assignee ~ operation_assign ~ expression ~ LINE_END}
statement_multiple_assignment = { "let" ~ "(" ~ variable_tuple ~ ")" ~ "=" ~  identifier ~ "(" ~ expression_tuple ~ ")" ~ LINE_END}
statement_conditional = {"if" ~ (expression | "(" ~ expression ~ ")") ~ "{" ~ NEWLINE* ~ statement+ ~ "}" ~ ("else" ~ conditional_nested_or_end)?}
statement_for = { "for" ~ identifier ~ "in" ~ expression ~ ".." ~ expression ~ "{" ~ NEWLINE* ~ statement+ ~ "}"}
statement_assert = {
    assert_eq
//     | assert_true |
}
statement_expression = { expression ~ LINE_END }

statement = {
    (statement_return
    | statement_conditional
    | statement_for
      | (statement_multiple_assignment
      | statement_assert
      | statement_definition
      | statement_assign
      | statement_expression
      )
    ) ~ NEWLINE*
}

/// Functions

input_model = {mutable? ~ identifier ~ ":" ~ visibility? ~ _type}
input_model_list = _{(input_model ~ ("," ~ input_model)*)?}

function_definition = {"function" ~ identifier ~ "(" ~ input_model_list ~ ")" ~ ("->" ~ (_type | "(" ~ type_list ~ ")"))? ~ "{" ~ NEWLINE* ~ statement* ~ NEWLINE* ~ "}" ~ NEWLINE* }

/// Utilities

COMMENT = _{ ("/*" ~ (!"*/" ~ ANY)* ~ "*/") | ("//" ~ (!NEWLINE ~ ANY)*) }
WHITESPACE = _{ " " | "\t" ~ (NEWLINE)* }
LINE_END = {";" ~ NEWLINE*}

/// Imports

import_source = @{(!"\"" ~ ANY)*}
import_symbol = { identifier ~ ("as" ~ identifier)? }
import_symbol_tuple = _{ import_symbol ~ ("," ~ NEWLINE* ~ import_symbol)* }

import = { "from" ~ "\"" ~ import_source ~ "\"" ~ "import" ~ ("*" | ("{" ~ NEWLINE* ~ import_symbol_tuple ~ NEWLINE* ~ "}") | import_symbol) ~ LINE_END}

/// Tests

test = {"test" ~ function_definition}

/// Program File

file = { SOI ~ NEWLINE* ~ import* ~ NEWLINE* ~ circuit_definition* ~ NEWLINE* ~ function_definition* ~ NEWLINE* ~ test* ~ NEWLINE* ~ EOI }
